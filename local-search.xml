<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React实战-从零开始</title>
    <link href="/2020/12/15/React%E5%AE%9E%E6%88%98-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/React%E5%AE%9E%E6%88%98-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    <url>/2020/12/15/React%E5%AE%9E%E6%88%98-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/React%E5%AE%9E%E6%88%98-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="环境配置和脚手架使用"><a href="#环境配置和脚手架使用" class="headerlink" title="环境配置和脚手架使用"></a>环境配置和脚手架使用</h1><blockquote><p>这些内容在上一篇文章中已经有提及，前提是已安装npm</p></blockquote><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><pre><code class="hljs dsconfig"><span class="hljs-string">npm </span><span class="hljs-string">install </span><span class="hljs-string">webpack </span>-g  <span class="hljs-comment"># 安装webpack（全局）</span><span class="hljs-string">npm </span><span class="hljs-string">install </span>-g <span class="hljs-built_in">create-react-app</span> <span class="hljs-comment"># 安装react构建程序（全局）</span></code></pre><h2 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h2><p>我们可以使用create-react-app快速构建一个react单页应用，更多关于create-react-app的信息可见其<a href="https://create-react-app.bootcss.com/">官方网站</a>。</p><pre><code class="hljs dsconfig"><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">demo-app </span>      <span class="hljs-comment"># 创建一个名为demo-app的react单页应用（自动安装依赖工具），也可使用npm init react-app my-app</span></code></pre><p>创建后得到名为demo-app的文件夹，文件结构如下</p><pre><code class="hljs stylus">my-app/  README.md  node_modules/  package.json  public/    index.html    favicon.ico  src/    App.css    App.js    App<span class="hljs-selector-class">.test</span>.js    index.css    index.js    logo.svg</code></pre><p>上述文件中，除了<code>public/index.html</code>（page template）和<code>src/index.js</code>（JavaScript entry point）两个文件不能修改文件名和路径外（内容可修改），其余文件均可删除或重命名。</p><p>其中<code>node_modules</code>存储安装的模块（如npm install echarts –save），<code>package.json</code>管理本地安装的npm包，这两类文件都无需额外维护，使用npm安装模块后会自动修改。npm相关信息可详见<a href="https://cloud.tencent.com/developer/section/1490235">npm教程文档</a>。</p><blockquote><p>如果是复制的别人的项目，运行前一般需要<code>npm install</code>指令安装项目所依赖的模块</p></blockquote><p>另外，只有 <code>src</code> 内部的文件由 webpack 处理，所有<strong>所有Js和Css文件都应该放入 src中</strong>，这些也是这次实战的主要要处理的文件；另外index.html仅能使用<code>public</code>目录中的文件。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h3 id="index-js和index-html"><a href="#index-js和index-html" class="headerlink" title="index.js和index.html"></a>index.js和index.html</h3><p>index.js做渲染工作，通过ReactDOM提供的render函数将React元素转为HTML结构并插入DOM节点。需要注意的是，多个React元素需要用一个父标签全部包括才能算做一个元素。</p><blockquote><p>Javascript中的Document对象可见<a href="https://www.w3school.com.cn/jsref/dom_obj_document.asp">教程</a></p></blockquote><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;  <span class="hljs-comment">// 自定义组件</span><span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reportWebVitals&#x27;</span>;<span class="hljs-comment">// ReactDOM.render(template,targetDOM)</span>ReactDOM.render(  <span class="hljs-comment">// 将组件模板转为HTML语言，并插入指定的DOM节点</span>  <span class="hljs-comment">// React.StrictMode组件 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告</span>  <span class="hljs-comment">// App组件 由App.js构建并导出</span>  &lt;React.StrictMode&gt;      &lt;App /&gt;     &lt;/React.StrictMode&gt;,  <span class="hljs-comment">// targetDOM 由getElementById在根节点下获取id为“root”的DOM节点，详见index.html</span>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));<span class="hljs-comment">// If you want to start measuring performance in your app, pass a function</span><span class="hljs-comment">// to log results (for example: reportWebVitals(console.log))</span><span class="hljs-comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span>reportWebVitals();  <span class="hljs-comment">// report信息</span></code></pre><h3 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h3><p>App.js定义了一个名为App的组件（函数组件），需要注意的是，组件定义后为了其他js文件能import，需要在定以后导出（export），如果导出多个，可以用export {aaa, bbb}，如果是从一个文件中导出一个组件，那就需要用default。</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>; <span class="hljs-comment">// 样式</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 函数组件</span>  <span class="hljs-keyword">return</span> (  <span class="hljs-comment">// 返回**一个**React元素</span>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;      &lt;header className=<span class="hljs-string">&quot;App-header&quot;</span>&gt;        &lt;img src=&#123;logo&#125; className=<span class="hljs-string">&quot;App-logo&quot;</span> alt=<span class="hljs-string">&quot;logo&quot;</span> /&gt;        &lt;p&gt;          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;        &lt;a          className=<span class="hljs-string">&quot;App-link&quot;</span>          href=<span class="hljs-string">&quot;https://reactjs.org&quot;</span>          target=<span class="hljs-string">&quot;_blank&quot;</span>          rel=<span class="hljs-string">&quot;noopener noreferrer&quot;</span>        &gt;          Learn React        &lt;/a&gt;      &lt;/header&gt;    &lt;/div&gt;  );&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;  <span class="hljs-comment">// 导出该组件，如果导出多个，可以用export &#123;aaa, bbb&#125;，如果是从一个文件中导出一个组件，那就需要用default</span></code></pre><p>总的来说，初始代码只是将App组件插入root节点，通过分析APP.js发现，该组件仅包含一个logo，一句提示和一条链接（当然也会有初始好的样式App.css），我们可以通过<code>npm start</code>指令运行代码，并在浏览器中进入<code>http://localhost:3000/</code>中进行查看，值得一提的是，我们可以一边运行一边修改代码，保存后修改会自动显示到页面上。<br><img src="/img/React%E5%AE%9E%E6%88%98_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B_editedPage.png" alt="Edited Page"></p><h1 id="组件库的使用"><a href="#组件库的使用" class="headerlink" title="组件库的使用"></a>组件库的使用</h1><blockquote><p>React、Vue这类前端框架很方便的一点是有大量的成熟UI组件库供开发者使用。组件库顾名思义，也就是一个包含许多已经编写好的组件的库，我们这次使用<a href="https://ant.design/docs/react/introduce-cn">Antd UI组件库</a>。</p></blockquote><p>我们可以在Antd官网的<a href="https://ant.design/components/overview-cn/">组件总览</a>中选取我们需要的组件</p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React实战-基础讲解</title>
    <link href="/2020/12/11/React%E5%9F%BA%E7%A1%80/React%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/12/11/React%E5%9F%BA%E7%A1%80/React%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>课程demo，我负责的任务是demo前端，正好学习并总结一下React的使用，本文先对React的基础知识做一些介绍，在此之前，需要对html、css和javascript的相关知识有一定了解</p></blockquote><p><em>本文仅对一些React相关的基础知识进行讲解，系统学习可参考文末的参考链接</em></p><h3 id="相关背景知识与概述"><a href="#相关背景知识与概述" class="headerlink" title="相关背景知识与概述"></a>相关背景知识与概述</h3><h4 id="WEB单页应用与多页应用"><a href="#WEB单页应用与多页应用" class="headerlink" title="WEB单页应用与多页应用"></a>WEB单页应用与多页应用</h4><h5 id="多页应用（MPA）"><a href="#多页应用（MPA）" class="headerlink" title="多页应用（MPA）"></a>多页应用（MPA）</h5><p>每一次页面跳转的时候，后台服务器都会给返回一个新的<code>html</code>文档，这种类型的网站也就是多页网站，也叫做多页应用。多页应用首屏时间快，SEO (搜索引擎优化) 效果好，但页面切换慢。</p><h5 id="单页应用（SPA）"><a href="#单页应用（SPA）" class="headerlink" title="单页应用（SPA）"></a>单页应用（SPA）</h5><p>第一次进入页面的时候会请求一个<code>html</code>文件，刷新清除一下。切换到其他组件，此时路径<code>url</code>也相应变化，<code>js</code>会感知到<code>url</code>的变化，通过这一点可以用<code>js</code>动态地将当前页面的内容清除，然后将下一个页面的内容挂载到当前页面上。这个时候的路由不再是后端来做了，而是前端来做，判断页面显示相应的组件，清除不需要的。以这种方式，没有新的<code>html</code>文件请求，页面内容也变化了。SPA的页面跳转是js渲染，页面切换快，但首屏时间（html请求+js请求）稍慢，SEO差。</p><p><img src="/img/React%E5%9F%BA%E7%A1%80_MPA&SPA.png" alt="React基础_MPA&amp;SPA"></p><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作<strong>“组件”</strong>。</p><h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p>webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。webpack依赖nodejs和npm。</p><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack -g  <span class="hljs-comment"># 全局安装</span></code></pre><h4 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h4><p>Create React App 是一个官方支持的创建 React <strong>单页应用</strong>程序的方法。它提供了一个零配置的现代构建设置。</p><pre><code class="hljs dsconfig"><span class="hljs-string">npm </span><span class="hljs-string">install </span>-g <span class="hljs-built_in">create-react-app</span> <span class="hljs-comment"># 利用npm全局安装</span><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">demo-app </span>      <span class="hljs-comment"># 创建react单页应用（自动安装依赖工具）</span><span class="hljs-string">cd </span><span class="hljs-string">demo-app</span><span class="hljs-string"></span><span class="hljs-string">npm </span><span class="hljs-string">run </span><span class="hljs-string">eject</span><span class="hljs-comment"># 生成配置文件（运行后eject命令会在package.json中被移除）</span><span class="hljs-string">npm </span><span class="hljs-string">start </span><span class="hljs-comment"># 开发模式运行程序（内置命令），在http://localhost:3000查看</span><span class="hljs-string">npm </span><span class="hljs-string">run </span><span class="hljs-string">build</span><span class="hljs-comment"># 将生产环境的应用程序构建到 build 目录</span></code></pre><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><p>建议在 React 中配合使用 JSX。JSX是JavaScript 的语法扩展，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。具体语法可见<a href="https://react.docschina.org/docs/introducing-jsx.html">JSX简介</a>、<a href="https://www.runoob.com/react/react-jsx.html">React JSX-菜鸟教程</a>。</p><h4 id="React元素与组件"><a href="#React元素与组件" class="headerlink" title="React元素与组件"></a>React元素与组件</h4><p>每一个 <strong>React 元素</strong>事实上都是一个 JavaScript 对象，可保存在<strong>变量</strong>中或者作为<strong>参数</strong>传递。React元素是一种对渲染内容的轻量级描述，大多数的 React 开发者使用了一种名为 “JSX” 的特殊语法，JSX 可以让你更轻松地书写这些结构。</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<span class="hljs-keyword">var</span> myDivElement = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;foo&quot;</span> /&gt;</span></span>; <span class="hljs-comment">//*&lt;div /&gt;会被编译成 React.createElement(&#x27;div&#x27;)。</span></code></pre><p>如果<strong>React元素</strong>对应<strong>常量/变量</strong>这一概念，<strong>组件</strong>则对应<strong>函数/类</strong>这一概念。如下所示，<code>ShoppingList</code> 是一个 <strong>React 组件类</strong>，或者说是一个 <strong>React 组件类型</strong>。一个组件接收一些参数，我们把这些参数叫做 <code>props</code>，然后通过 <code>render</code> 方法返回一个<strong>React元素</strong>（该组件需要展示在屏幕上的视图的层次结构）。组件名首字母必须大写。</p><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// React.Component是React多种类型组件中的一种</span>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div className=<span class="hljs-string">&quot;shopping-list&quot;</span>&gt;        &lt;h1&gt;Shopping List <span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">this</span>.props.name&#125;&lt;/h1&gt;        &lt;ul&gt;          &lt;li&gt;Instagram&lt;/li&gt;           &lt;li&gt;WhatsApp&lt;/li&gt;          &lt;li&gt;Oculus&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-comment">// 用法示例: &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span></code></pre><h4 id="DOM与ReactDOM"><a href="#DOM与ReactDOM" class="headerlink" title="DOM与ReactDOM"></a>DOM与ReactDOM</h4><p><em>浏览器代码解析与页面渲染：DOM构造 =&gt;布局（文档流） =&gt;页面绘制</em></p><p>DOM (Document Object Model) 译为<strong>文档对象模型</strong>，是 W3C（万维网联盟）的标准，分为三个部分：</p><ul><li><p>核心DOM：针对任何结构化文档的标准模型</p></li><li><p>XML DOM：针对 XML 文档的标准模型，定义访问和操作XML文档的标准方法，即定义了所有 XML 元素的<strong>对象</strong>和<strong>属性</strong>，以及访问它们的<strong>方法</strong>。DOM 将 XML 文档作为一个树形结构，而树叶被定义为节点。</p><blockquote><p>XML，可扩展标记语言，是一种很像HTML的<strong>标记语言</strong>，被设计用来传输和存储数据，需要自定义标签。</p></blockquote></li><li><p>HTML DOM：针对 HTML 文档的标准模型，定义了访问和操作 HTML 文档的标准，即定义了所有 HTML 元素的<strong>对象和属性</strong>，以及访问它们的<strong>方法</strong>（接口）。DOM同样以树结构表达 HTML 文档。</p><blockquote><p>HTML，超文本标记语言，是一种用于创建网页的标准<strong>标记语言</strong>，包含了HTML <strong>标签</strong>及<strong>文本</strong>内容，HTML 运行在浏览器上，由浏览器来解析</p></blockquote></li></ul><p>React的DOM操作（<strong>ReactDOM</strong>）单独由react-dom包提供，常用其提供的<code>render</code>操作，如下，1）在提供的 <code>container</code> 里渲染一个<strong>React 元素</strong>，并返回对该组件的引用（或者针对无状态组件返回 <code>null</code>），2）如果 React 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素，3）如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><pre><code class="hljs js">ReactDOM.render(element, container[, callback])  <span class="hljs-comment">// 渲染、更新、回调</span></code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="函数组件与class组件"><a href="#函数组件与class组件" class="headerlink" title="函数组件与class组件"></a>函数组件与class组件</h4><p>组件的最终目的是返回一个React元素，定义组件最简单的方式就是编写 JavaScript 函数（函数组件）：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;</code></pre><p>使用ES6的class来定义组件，两个组件在 React 里是等效的：</p><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;</code></pre><p>当使用自定义组件时，标签属性以及子组件会被转换成<strong>props</strong>对象传递给组件（class组件通过this.props访问）</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 函数组件Welcome，接收props对象</span>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  <span class="hljs-comment">// 通过props.name获取name属性</span>&#125;<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;  <span class="hljs-comment">// 使用自定义组件Welcome，并设定属性name=&quot;Sara&quot;</span>ReactDOM.render(  <span class="hljs-comment">// 使用ReactDOM提供的render函数渲染元素</span>  element,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre><p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p><h4 id="class组件中的state与生命周期"><a href="#class组件中的state与生命周期" class="headerlink" title="class组件中的state与生命周期"></a>class组件中的state与生命周期</h4><p>使用ES6的class来定义组件，class组件中存在状态state，通过this.state访问。需要注意的是，state是组件自己维护的一个javaScript对象，而props是传入的、不可修改的对象（可理解为形参）。在 React 中，<code>this.props</code> 和 <code>this.state</code> 都代表着<strong>已经被渲染了的</strong>值，即当前屏幕上显示的值。</p><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123; <span class="hljs-comment">// 非必需</span>    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;   <span class="hljs-comment">// 可在构造函数中对state进行初始化</span>  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">//必需</span>    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="hljs-regexp">/h2&gt;  /</span><span class="hljs-regexp">/ 通过this.state访问State</span><span class="hljs-regexp">      &lt;/</span>div&gt;    );  &#125;&#125;ReactDOM.render(  &lt;Clock /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre><p>另外，除了初始化外，state并不能直接被修改，组件提供**this.setState()**方法更新组件的State，setState的调用会引发一次组件的更新（详见下文组件生命周期），从而引发重新绘制，即该组件重新渲染。</p><pre><code class="hljs pf"><span class="hljs-built_in">set</span>State(updater[, callback]) // callback是<span class="hljs-keyword">state</span>导致的页面重新渲染的回调</code></pre><p>需要注意的是，setState是<strong>异步且分批执行</strong>的，连续多次setState函数调用产生的效果会合并。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">incrementCount</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-comment">// 注意：这样 *不会* 像预期的那样工作。</span>  <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-title">handleSomething</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-comment">// 假设 `this.state.count` 从 0 开始。</span>  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-comment">// 当 React 重新渲染该组件时，`this.state.count` 会变为 1，而不是你期望的 3。</span>  <span class="hljs-comment">// 这是因为上面的 `incrementCount()` 函数是从 `this.state.count` 中读取数据的，</span>  <span class="hljs-comment">// 但是 React 不会更新 `this.state.count`，直到该组件被重新渲染（`this.props` 和 `this.state` 都代表着*已经被渲染了的*值）。</span>  <span class="hljs-comment">// 所以最终 `incrementCount()` 每次读取 `this.state.count` 的值都是 0，并将它设为 1。</span>&#125;</code></pre><p>要修复上述问题，可以给 <code>setState</code> 传递一个函数，而不是一个对象，就可以确保每次的调用都是使用最新版的 state。当参数是函数的时候，setState() 会将上一个 setState() 的结果作为参数传入这个函数（链式地进行更新，并确保它们是一个建立在另一个之上的）。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">incrementCount</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 重要：在更新的时候读取 `state`（pre_state），而不是 `this.state`。</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;  &#125;);&#125;<span class="hljs-function"><span class="hljs-title">handleSomething</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-comment">// 假设 `this.state.count` 从 0 开始。</span>  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-built_in">this</span>.incrementCount();  <span class="hljs-comment">// 如果你现在在这里读取 `this.state.count`，它还是会为 0。</span>  <span class="hljs-comment">// 但是，当 React 重新渲染该组件时，它会变为 3。</span>&#125;</code></pre><p><strong>组件生命周期</strong>可见<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">官方生命周期图谱<img src="img/React%E5%9F%BA%E7%A1%80_process.png" alt="React基础_process"></a></p><p>每个组件都包含 “生命周期方法”，可重写这些方法以便于在运行过程中特定的阶段执行特定操作，包括：</p><ul><li>constructor()，构造函数，React 组件挂载之前，会调用这个函数。一般重写该函数来给 <code>this.state</code> 赋初始值或为时间处理函数绑定实例。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用<code>super(props)</code>，否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug</li><li>getDriveredStateFromProps()</li><li>render()，<code>render()</code> 方法是 class 组件中唯一必须实现的方法，它检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回React元素，在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</li><li>componentDidMount()，<code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里，需要注意的是组件mount后，上层组件使其props更新后仅会update而不会重新mount。</li><li>**componentDidUpdate()**，<code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</li><li>**componentWillUnmount()**，<code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，如清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</li></ul><blockquote><ol><li>当 <code>&lt;Clock /&gt;</code> 被传递给 <code>ReactDOM.render()</code> 时，React 调用 <code>Clock</code> 组件的构造函数。 由于 <code>Clock</code> 需要显示当前时间，所以使用包含当前时间的对象来初始化 <code>this.state</code> 。 我们稍后会更新此状态。</li><li>React 然后调用 <code>Clock</code> 组件的 <code>render()</code> 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 <code>Clock</code> 的渲染输出。</li><li>当 <code>Clock</code> 的输出插入到 DOM 中时，React 调用 <code>componentDidMount()</code> 生命周期<a href="#">钩子</a>。 在其中，<code>Clock</code> 组件要求浏览器设置一个定时器，每秒钟调用一次 <code>tick()</code>。</li><li>浏览器每秒钟调用 <code>tick()</code> 方法。 在其中，<code>Clock</code> 组件通过使用包含当前时间的对象调用 <code>setState()</code> 来调度UI更新。 通过调用 <code>setState()</code> ，React 知道状态已经改变，并再次调用 <code>render()</code> 方法来确定屏幕上应当显示什么。 这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。</li><li>一旦 <code>Clock</code> 组件被从 DOM 中移除，React 会调用 <code>componentWillUnmount()</code> 这个钩子函数，定时器也就会被清除。</li></ol></blockquote><h4 id="数据向下流动与状态提升"><a href="#数据向下流动与状态提升" class="headerlink" title="数据向下流动与状态提升"></a>数据向下流动与状态提升</h4><p><strong>组件复合</strong>指通过创建多个组件合成一个组件，如下，下层组件<code>Welcome</code>接受上层组件<code>App</code>提供的数据构建组件。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 下层组件</span>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  <span class="hljs-comment">// 下层组件接受上层组件提供的props</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 上层组件 ancestor.</span>  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;      &lt;Welcome name=<span class="hljs-string">&quot;Cahal&quot;</span> /&gt;      &lt;Welcome name=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;    &lt;/div&gt;  );&#125;ReactDOM.render(  &lt;App /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre><p>通过上面关于<code>props</code>和<code>state</code>的介绍，我们知道<code>props</code>只能由上层级组件传入下层级组件，所以称为<strong>向下流动的数据</strong>，而<code>state</code>又只能在当前组件中记录状态，直接使用<code>props</code>和<code>state</code>似乎无法完成<strong>下层级到上层级</strong>或<strong>同层级组件</strong>间的数据传输，但结合回调函数，我们可以以一种名为<strong>状态提升</strong>的方式实现</p><p>以下层组件向上层组件传输数据为例，我们有上层组件<code>Base</code>，下层组件<code>Child</code>，通过用户输入我们在<code>Child</code>中获得数据<code>data</code>，我们的目标是将<code>data</code>从<code>Child</code>传入<code>Base</code>中。</p><p>首先我们在<code>Base</code>中设定一个修改/传递数据的函数<code>handleData</code>，将<code>handleData</code>这个函数通过<code>props</code>传入<code>Child</code>，当<code>Child</code>获得<code>data</code>后，通过一定的事件（如点击<code>onClick</code>事件）调用父级组件的<code>handleData</code>函数，将<code>data</code>传入<code>Base</code>。</p><p>如下是一个状态提升的示例，程序提供两个输入框分别显示华氏温度和摄氏温度，用户输入其中一个，另一个输入框根据输入自动更新，详细信息可见<a href="https://reactjs.bootcss.com/docs/lifting-state-up.html">状态提升-React中文文档</a>。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) </span>&#123;  <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(input)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;  &#125;  <span class="hljs-keyword">const</span> output = convert(input);  <span class="hljs-keyword">const</span> rounded = <span class="hljs-built_in">Math</span>.round(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;  <span class="hljs-keyword">return</span> rounded.toString();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123; <span class="hljs-comment">// 上层组件</span>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.handleCelsiusChange = <span class="hljs-built_in">this</span>.handleCelsiusChange.bind(<span class="hljs-built_in">this</span>);    <span class="hljs-built_in">this</span>.handleFahrenheitChange = <span class="hljs-built_in">this</span>.handleFahrenheitChange.bind(<span class="hljs-built_in">this</span>);    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">handleCelsiusChange</span>(<span class="hljs-params">temperature</span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>, temperature&#125;);  &#125;  <span class="hljs-function"><span class="hljs-title">handleFahrenheitChange</span>(<span class="hljs-params">temperature</span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;f&#x27;</span>, temperature&#125;);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.state.scale;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.state.temperature;    <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">&#x27;f&#x27;</span> ? tryConvert(temperature, toCelsius) : temperature;    <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">&#x27;c&#x27;</span> ? tryConvert(temperature, toFahrenheit) : temperature;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;TemperatureInput          scale=<span class="hljs-string">&quot;c&quot;</span>          temperature=&#123;celsius&#125;          onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleCelsiusChange&#125; /&gt;        &lt;TemperatureInput          scale=<span class="hljs-string">&quot;f&quot;</span>          temperature=&#123;fahrenheit&#125;          onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleFahrenheitChange&#125; /&gt;        &lt;BoilingVerdict          celsius=&#123;<span class="hljs-built_in">parseFloat</span>(celsius)&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-keyword">const</span> scaleNames = &#123;  c: <span class="hljs-string">&#x27;Celsius&#x27;</span>,  f: <span class="hljs-string">&#x27;Fahrenheit&#x27;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.handleChange = <span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">e</span>)</span> &#123;    <span class="hljs-built_in">this</span>.props.onTemperatureChange(e.target.value);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.props.temperature;    <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.props.scale;    <span class="hljs-keyword">return</span> (      &lt;fieldset&gt;        &lt;legend&gt;Enter temperature <span class="hljs-keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;/legend&gt;        &lt;input value=&#123;temperature&#125;               onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125; /&gt;      &lt;/fieldset&gt;    );  &#125;&#125;</code></pre><p>参考资料：</p><p><a href="https://www.jianshu.com/p/a02eb15d2d70">SPA（单页面应用）和MPA（多页面应用）</a></p><p><a href="https://www.html.cn/create-react-app/">Create React App 中文文档</a></p><p><a href="https://www.runoob.com/react/react-tutorial.html">React教程-菜鸟教程</a></p><p><a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">HTML DOM 教程-菜鸟教程</a></p><p><a href="https://blog.csdn.net/b954960630/article/details/80216160">React学习：状态提升 实例</a></p><p><a href="https://segmentfault.com/q/1010000014782282">关于e.target</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/16/hello-world/"/>
    <url>/2020/11/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
