

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Pastry97">
  <meta name="keywords" content="">
  <title>React基础 - Pastry97&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":5},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pastry's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-11 15:36" pubdate>
        December 11, 2020 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React基础</h1>
            
            <div class="markdown-body">
              <h3 id="相关背景知识与概述"><a href="#相关背景知识与概述" class="headerlink" title="相关背景知识与概述"></a>相关背景知识与概述</h3><h4 id="WEB单页应用与多页应用"><a href="#WEB单页应用与多页应用" class="headerlink" title="WEB单页应用与多页应用"></a>WEB单页应用与多页应用</h4><h5 id="多页应用（MPA）"><a href="#多页应用（MPA）" class="headerlink" title="多页应用（MPA）"></a>多页应用（MPA）</h5><p>每一次页面跳转的时候，后台服务器都会给返回一个新的<code>html</code>文档，这种类型的网站也就是多页网站，也叫做多页应用。多页应用首屏时间快，SEO (搜索引擎优化) 效果好，但页面切换慢。</p>
<h5 id="单页应用（SPA）"><a href="#单页应用（SPA）" class="headerlink" title="单页应用（SPA）"></a>单页应用（SPA）</h5><p>第一次进入页面的时候会请求一个<code>html</code>文件，刷新清除一下。切换到其他组件，此时路径<code>url</code>也相应变化，<code>js</code>会感知到<code>url</code>的变化，通过这一点可以用<code>js</code>动态地将当前页面的内容清除，然后将下一个页面的内容挂载到当前页面上。这个时候的路由不再是后端来做了，而是前端来做，判断页面显示相应的组件，清除不需要的。以这种方式，没有新的<code>html</code>文件请求，页面内容也变化了。SPA的页面跳转是js渲染，页面切换快，但首屏时间（html请求+js请求）稍慢，SEO差。</p>


<p><img src="11880611-4dbea14cfa0b17c0.png" srcset="/img/loading.gif" alt="11880611-4dbea14cfa0b17c0"></p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作<strong>“组件”</strong>。</p>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><h4 id="脚手架-webpack"><a href="#脚手架-webpack" class="headerlink" title="脚手架-webpack"></a>脚手架-webpack</h4><p>webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。webpack依赖nodejs和npm。</p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack -g  <span class="hljs-comment"># 全局安装</span></code></pre>

<h4 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h4><p>Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。</p>
<pre><code class="hljs dsconfig"><span class="hljs-string">npm </span><span class="hljs-string">install </span>-g <span class="hljs-built_in">create-react-app</span> <span class="hljs-comment"># 利用npm全局安装</span>
<span class="hljs-built_in">create-react-app</span> <span class="hljs-string">demo-app </span>      <span class="hljs-comment"># 创建react单页应用（自动安装依赖工具）</span>
<span class="hljs-string">cd </span><span class="hljs-string">demo-app</span>
<span class="hljs-string"></span>
<span class="hljs-string">npm </span><span class="hljs-string">run </span><span class="hljs-string">eject	</span>				<span class="hljs-comment"># 生成配置文件（运行后eject命令会在package.json中被移除）</span>
<span class="hljs-string">npm </span><span class="hljs-string">start </span>						<span class="hljs-comment"># 开发模式运行程序（内置命令），在http://localhost:3000查看</span>
<span class="hljs-string">npm </span><span class="hljs-string">run </span><span class="hljs-string">build	</span>				<span class="hljs-comment"># 将生产环境的应用程序构建到 build 目录</span></code></pre>



<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><p>建议在 React 中配合使用 JSX。JSX是JavaScript 的语法扩展，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。具体语法可见<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/introducing-jsx.html">JSX简介</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/react/react-jsx.html">React JSX-菜鸟教程</a>。</p>
<h4 id="React元素与组件"><a href="#React元素与组件" class="headerlink" title="React元素与组件"></a>React元素与组件</h4><p>每一个 <strong>React 元素</strong>事实上都是一个 JavaScript 对象，可保存在<strong>变量</strong>中或者作为<strong>参数</strong>传递。React元素是一种对渲染内容的轻量级描述，大多数的 React 开发者使用了一种名为 “JSX” 的特殊语法，JSX 可以让你更轻松地书写这些结构。</p>
<pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
<span class="hljs-keyword">var</span> myDivElement = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;foo&quot;</span> /&gt;</span></span>; <span class="hljs-comment">//*&lt;div /&gt;会被编译成 React.createElement(&#x27;div&#x27;)。</span></code></pre>

<p>如果<strong>React元素</strong>对应<strong>常量/变量</strong>这一概念，<strong>组件</strong>则对应<strong>函数/类</strong>这一概念。如下所示，<code>ShoppingList</code> 是一个 <strong>React 组件类</strong>，或者说是一个 <strong>React 组件类型</strong>。一个组件接收一些参数，我们把这些参数叫做 <code>props</code>，然后通过 <code>render</code> 方法返回一个<strong>React元素</strong>（该组件需要展示在屏幕上的视图的层次结构）。组件名首字母必须大写。</p>
<pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// React.Component是React多种类型组件中的一种</span>
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> (
      &lt;div className=<span class="hljs-string">&quot;shopping-list&quot;</span>&gt;
        &lt;h1&gt;Shopping List <span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">this</span>.props.name&#125;&lt;/h1&gt;
        &lt;ul&gt;
          &lt;li&gt;Instagram&lt;/li&gt; 
          &lt;li&gt;WhatsApp&lt;/li&gt;
          &lt;li&gt;Oculus&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

<span class="hljs-comment">// 用法示例: &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span></code></pre>

<h4 id="DOM与ReactDOM"><a href="#DOM与ReactDOM" class="headerlink" title="DOM与ReactDOM"></a>DOM与ReactDOM</h4><p><em>浏览器代码解析与页面渲染：DOM构造 =&gt;布局（文档流） =&gt;页面绘制</em></p>
<p>DOM (Document Object Model) 译为<strong>文档对象模型</strong>，是 W3C（万维网联盟）的标准，分为三个部分：</p>
<ul>
<li><p>核心DOM：针对任何结构化文档的标准模型</p>
</li>
<li><p>XML DOM：针对 XML 文档的标准模型，定义访问和操作XML文档的标准方法，即定义了所有 XML 元素的<strong>对象</strong>和<strong>属性</strong>，以及访问它们的<strong>方法</strong>。DOM 将 XML 文档作为一个树形结构，而树叶被定义为节点。</p>
<blockquote>
<p>XML，可扩展标记语言，是一种很像HTML的<strong>标记语言</strong>，被设计用来传输和存储数据，需要自定义标签。</p>
</blockquote>
</li>
<li><p>HTML DOM：针对 HTML 文档的标准模型，定义了访问和操作 HTML 文档的标准，即定义了所有 HTML 元素的<strong>对象和属性</strong>，以及访问它们的<strong>方法</strong>（接口）。DOM同样以树结构表达 HTML 文档。</p>
<blockquote>
<p>HTML，超文本标记语言，是一种用于创建网页的标准<strong>标记语言</strong>，包含了HTML <strong>标签</strong>及<strong>文本</strong>内容，HTML 运行在浏览器上，由浏览器来解析</p>
</blockquote>
</li>
</ul>
<p>React的DOM操作（<strong>ReactDOM</strong>）单独由react-dom包提供，常用其提供的<code>render</code>操作，如下，1）在提供的 <code>container</code> 里渲染一个<strong>React 元素</strong>，并返回对该组件的引用（或者针对无状态组件返回 <code>null</code>），2）如果 React 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素，3）如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p>
<pre><code class="hljs js">ReactDOM.render(element, container[, callback])  <span class="hljs-comment">// 渲染、更新、回调</span></code></pre>



<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="函数组件与class组件"><a href="#函数组件与class组件" class="headerlink" title="函数组件与class组件"></a>函数组件与class组件</h4><p>组件的最终目的是返回一个React元素，定义组件最简单的方式就是编写 JavaScript 函数（函数组件）：</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
&#125;</code></pre>

<p>使用ES6的class来定义组件，两个组件在 React 里是等效的：</p>
<pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  &#125;
&#125;</code></pre>

<p>当使用自定义组件时，标签属性以及子组件会被转换成<strong>props</strong>对象传递给组件（class组件通过this.props访问）</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 函数组件Welcome，接收props对象</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  <span class="hljs-comment">// 通过props.name获取name属性</span>
&#125;

<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;  <span class="hljs-comment">// 使用自定义组件Welcome，并设定属性name=&quot;Sara&quot;</span>
ReactDOM.render(  <span class="hljs-comment">// 使用ReactDOM提供的render函数渲染元素</span>
  element,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)
);</code></pre>

<p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p>
<h4 id="class组件中的state与生命周期"><a href="#class组件中的state与生命周期" class="headerlink" title="class组件中的state与生命周期"></a>class组件中的state与生命周期</h4><p>使用ES6的class来定义组件，class组件中存在状态state，通过this.state访问。需要注意的是，state是组件自己维护的一个javaScript对象，而props是传入的、不可修改的对象（可理解为形参）。在 React 中，<code>this.props</code> 和 <code>this.state</code> 都代表着<strong>已经被渲染了的</strong>值，即当前屏幕上显示的值。</p>
<pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123; <span class="hljs-comment">// 非必需</span>
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;   <span class="hljs-comment">// 可在构造函数中对state进行初始化</span>
  &#125;

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">//必需</span>
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="hljs-regexp">/h2&gt;  /</span><span class="hljs-regexp">/ 通过this.state访问State</span>
<span class="hljs-regexp">      &lt;/</span>div&gt;
    );
  &#125;
&#125;

ReactDOM.render(
  &lt;Clock /&gt;,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)
);</code></pre>

<p>另外，除了初始化外，state并不能直接被修改，组件提供**this.setState()**方法更新组件的State，setState的调用会引发一次组件的更新（详见下文组件生命周期），从而引发重新绘制，即该组件重新渲染。</p>
<pre><code class="hljs pf"><span class="hljs-built_in">set</span>State(updater[, callback]) // callback是<span class="hljs-keyword">state</span>导致的页面重新渲染的回调</code></pre>

<p>需要注意的是，setState是<strong>异步且分批执行</strong>的，连续多次setState函数调用产生的效果会合并。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">incrementCount</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-comment">// 注意：这样 *不会* 像预期的那样工作。</span>
  <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);
&#125;

<span class="hljs-function"><span class="hljs-title">handleSomething</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-comment">// 假设 `this.state.count` 从 0 开始。</span>
  <span class="hljs-built_in">this</span>.incrementCount();
  <span class="hljs-built_in">this</span>.incrementCount();
  <span class="hljs-built_in">this</span>.incrementCount();
  <span class="hljs-comment">// 当 React 重新渲染该组件时，`this.state.count` 会变为 1，而不是你期望的 3。</span>

  <span class="hljs-comment">// 这是因为上面的 `incrementCount()` 函数是从 `this.state.count` 中读取数据的，</span>
  <span class="hljs-comment">// 但是 React 不会更新 `this.state.count`，直到该组件被重新渲染（`this.props` 和 `this.state` 都代表着*已经被渲染了的*值）。</span>
  <span class="hljs-comment">// 所以最终 `incrementCount()` 每次读取 `this.state.count` 的值都是 0，并将它设为 1。</span>
&#125;</code></pre>

<p>要修复上述问题，可以给 <code>setState</code> 传递一个函数，而不是一个对象，就可以确保每次的调用都是使用最新版的 state。当参数是函数的时候，setState() 会将上一个 setState() 的结果作为参数传入这个函数（链式地进行更新，并确保它们是一个建立在另一个之上的）。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">incrementCount</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// 重要：在更新的时候读取 `state`（pre_state），而不是 `this.state`。</span>
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;
  &#125;);
&#125;

<span class="hljs-function"><span class="hljs-title">handleSomething</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-comment">// 假设 `this.state.count` 从 0 开始。</span>
  <span class="hljs-built_in">this</span>.incrementCount();
  <span class="hljs-built_in">this</span>.incrementCount();
  <span class="hljs-built_in">this</span>.incrementCount();

  <span class="hljs-comment">// 如果你现在在这里读取 `this.state.count`，它还是会为 0。</span>
  <span class="hljs-comment">// 但是，当 React 重新渲染该组件时，它会变为 3。</span>
&#125;</code></pre>

<p><strong>组件生命周期</strong>可见<a target="_blank" rel="noopener" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">官方生命周期图谱<img src="1607660543(1).png" srcset="/img/loading.gif" alt="1607660543(1)"></a></p>
<p>每个组件都包含 “生命周期方法”，可重写这些方法以便于在运行过程中特定的阶段执行特定操作，包括：</p>
<ul>
<li>**constructor()**，构造函数，React 组件挂载之前，会调用这个函数。一般重写该函数来给 <code>this.state</code> 赋初始值或为时间处理函数绑定实例。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用<code>super(props)</code>，否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug</li>
<li>getDriveredStateFromProps()</li>
<li>**render()**，<code>render()</code> 方法是 class 组件中唯一必须实现的方法，它检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回React元素，在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</li>
<li>**componentDidMount()**，<code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。</li>
<li>**componentDidUpdate()**，<code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</li>
<li>**componentWillUnmount()**，<code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，如清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</li>
</ul>
<blockquote>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传递给 <code>ReactDOM.render()</code> 时，React 调用 <code>Clock</code> 组件的构造函数。 由于 <code>Clock</code> 需要显示当前时间，所以使用包含当前时间的对象来初始化 <code>this.state</code> 。 我们稍后会更新此状态。</li>
<li>React 然后调用 <code>Clock</code> 组件的 <code>render()</code> 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 <code>Clock</code> 的渲染输出。</li>
<li>当 <code>Clock</code> 的输出插入到 DOM 中时，React 调用 <code>componentDidMount()</code> 生命周期<a href="#">钩子</a>。 在其中，<code>Clock</code> 组件要求浏览器设置一个定时器，每秒钟调用一次 <code>tick()</code>。</li>
<li>浏览器每秒钟调用 <code>tick()</code> 方法。 在其中，<code>Clock</code> 组件通过使用包含当前时间的对象调用 <code>setState()</code> 来调度UI更新。 通过调用 <code>setState()</code> ，React 知道状态已经改变，并再次调用 <code>render()</code> 方法来确定屏幕上应当显示什么。 这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。</li>
<li>一旦 <code>Clock</code> 组件被从 DOM 中移除，React 会调用 <code>componentWillUnmount()</code> 这个钩子函数，定时器也就会被清除。</li>
</ol>
</blockquote>
<h4 id="数据向下流动与状态提升"><a href="#数据向下流动与状态提升" class="headerlink" title="数据向下流动与状态提升"></a>数据向下流动与状态提升</h4><p><strong>组件复合</strong>指通过创建多个组件合成一个组件，如下，下层组件<code>Welcome</code>接受上层组件<code>App</code>提供的数据构建组件。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 下层组件</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  <span class="hljs-comment">// 下层组件接受上层组件提供的props</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 上层组件 ancestor.</span>
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;
      &lt;Welcome name=<span class="hljs-string">&quot;Cahal&quot;</span> /&gt;
      &lt;Welcome name=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;
    &lt;/div&gt;
  );
&#125;

ReactDOM.render(
  &lt;App /&gt;,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)
);</code></pre>

<p>通过上面关于<code>props</code>和<code>state</code>的介绍，我们知道<code>props</code>只能由上层级组件传入下层级组件，所以称为<strong>向下流动的数据</strong>，而<code>state</code>又只能在当前组件中记录状态，直接使用<code>props</code>和<code>state</code>似乎无法完成<strong>下层级到上层级</strong>或<strong>同层级组件</strong>间的数据传输，但结合回调函数，我们可以以一种名为<strong>状态提升</strong>的方式实现</p>
<p>以下层组件向上层组件传输数据为例，我们有上层组件<code>Base</code>，下层组件<code>Child</code>，通过用户输入我们在<code>Child</code>中获得数据<code>data</code>，我们的目标是将<code>data</code>从<code>Child</code>传入<code>Base</code>中。首先我们在<code>Base</code>中设定一个状态<code>this.state.data</code>（非必需）以及一个修改/传递数据的函数<code>handleData</code>（必需），并将<code>handleData</code>这个函数通过<code>props</code>传入<code>Child</code>，当<code>Child</code>获得<code>data</code>后，通过一定的事件（如点击<code>onClick</code>事件）调用父级组件的<code>handleData</code>函数，将<code>data</code>传入<code>Base</code>。</p>
<p>如下是一个状态提升的示例，程序提供两个输入框分别显示华氏温度和摄氏温度，用户输入其中一个，另一个输入框根据输入自动更新，详细信息可见<a target="_blank" rel="noopener" href="https://reactjs.bootcss.com/docs/lifting-state-up.html">状态提升-React中文文档</a>。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) </span>&#123;
  <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(input)) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  &#125;
  <span class="hljs-keyword">const</span> output = convert(input);
  <span class="hljs-keyword">const</span> rounded = <span class="hljs-built_in">Math</span>.round(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;
  <span class="hljs-keyword">return</span> rounded.toString();
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123; <span class="hljs-comment">// 上层组件</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.handleCelsiusChange = <span class="hljs-built_in">this</span>.handleCelsiusChange.bind(<span class="hljs-built_in">this</span>);
    <span class="hljs-built_in">this</span>.handleFahrenheitChange = <span class="hljs-built_in">this</span>.handleFahrenheitChange.bind(<span class="hljs-built_in">this</span>);
    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;
  &#125;

  <span class="hljs-function"><span class="hljs-title">handleCelsiusChange</span>(<span class="hljs-params">temperature</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>, temperature&#125;);
  &#125;

  <span class="hljs-function"><span class="hljs-title">handleFahrenheitChange</span>(<span class="hljs-params">temperature</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;f&#x27;</span>, temperature&#125;);
  &#125;

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.state.scale;
    <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.state.temperature;
    <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">&#x27;f&#x27;</span> ? tryConvert(temperature, toCelsius) : temperature;
    <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">&#x27;c&#x27;</span> ? tryConvert(temperature, toFahrenheit) : temperature;

    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;TemperatureInput
          scale=<span class="hljs-string">&quot;c&quot;</span>
          temperature=&#123;celsius&#125;
          onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleCelsiusChange&#125; /&gt;
        &lt;TemperatureInput
          scale=<span class="hljs-string">&quot;f&quot;</span>
          temperature=&#123;fahrenheit&#125;
          onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleFahrenheitChange&#125; /&gt;
        &lt;BoilingVerdict
          celsius=&#123;<span class="hljs-built_in">parseFloat</span>(celsius)&#125; /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

<span class="hljs-keyword">const</span> scaleNames = &#123;
  c: <span class="hljs-string">&#x27;Celsius&#x27;</span>,
  f: <span class="hljs-string">&#x27;Fahrenheit&#x27;</span>
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.handleChange = <span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);
  &#125;

  <span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">e</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.props.onTemperatureChange(e.target.value);
  &#125;

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.props.temperature;
    <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.props.scale;
    <span class="hljs-keyword">return</span> (
      &lt;fieldset&gt;
        &lt;legend&gt;Enter temperature <span class="hljs-keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;/legend&gt;
        &lt;input value=&#123;temperature&#125;
               onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125; /&gt;
      &lt;/fieldset&gt;
    );
  &#125;
&#125;</code></pre>







<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a02eb15d2d70">SPA（单页面应用）和MPA（多页面应用）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.html.cn/create-react-app/">Create React App 中文文档</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/react/react-tutorial.html">React教程-菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/htmldom/htmldom-tutorial.html">HTML DOM 教程-菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/b954960630/article/details/80216160">React学习：状态提升 实例</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000014782282">关于e.target</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/16/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
